// Generated by CoffeeScript 2.5.0
(function() {
  var Color, HoverBox, StyleContext, cn, css,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  css = require('./HoverBox.less');

  cn = require('classnames');

  Color = require('color');

  ({StyleContext} = require('./Style.coffee'));

  Math.clamp = function(num, min, max) {
    return Math.min(Math.max(num, min), max);
  };

  HoverBox = class HoverBox extends Component {
    constructor() {
      super();
      this.overlayRef = this.overlayRef.bind(this);
      this.resetHideTimer = this.resetHideTimer.bind(this);
      this.onMouseEnter = this.onMouseEnter.bind(this);
      this.onMouseLeave = this.onMouseLeave.bind(this);
      this.onClickOverlay = this.onClickOverlay.bind(this);
      this.setBackdropColor = this.setBackdropColor.bind(this);
      this.refBox = this.refBox.bind(this);
      this.state = {
        offset_left: 0,
        offset_top: 0
      };
    }

    onComponentDidMount() {}

    // @_overlay
    getBoxPosition() {
      var align_x, align_y, bar_h, bar_w, bar_x, bar_y, btn, dim, el, get_rect, height, max_x, max_y, min_x, min_y, overlay_rect, pad, pad_top, pos_x, pos_y, snap_x, snap_y, width;
      overlay_rect = this._overlay.getBoundingClientRect();
      el = this.props.getBindElement();
      dim = this.props.getSize();
      get_rect = el.getBoundingClientRect();
      btn = {
        top: get_rect.top,
        bottom: get_rect.bottom,
        left: get_rect.left,
        right: get_rect.right,
        width: get_rect.width,
        height: get_rect.height
      };
      // log btn
      snap_y = this.props.snap_y;
      snap_x = this.props.snap_x;
      if (snap_x && snap_y) {
        snap_y = 0;
      }
      if (!snap_x && !snap_y) {
        snap_y = 1;
      }
      align_x = this.props.align_x;
      align_y = this.props.align_y;
      pos_x = 0;
      pos_y = 0;
      // max_y = @props.max_y || window.innerHeight
      // max_x = @props.max_x || window.innerWidth
      pad = 8;
      pad_top = DIM + 3.75 * 2;
      height = Math.min(overlay_rect.bottom - overlay_rect.top - pad - pad_top, dim.height);
      width = Math.min(overlay_rect.right - overlay_rect.left - pad * 2, dim.width);
      // log overlay_rect.right-overlay_rect.left
      bar_x = 0;
      bar_y = 0;
      bar_w = 6;
      bar_h = 6;
      min_x = overlay_rect.left + pad_top;
      max_x = overlay_rect.right - pad - width;
      min_y = overlay_rect.top + pad;
      max_y = overlay_rect.bottom - pad - height;
      if (snap_y > 0) {
        pos_y = btn.bottom + pad;
      } else if (snap_y < 0) {
        pos_y = btn.top - height - pad;
      } else if (align_y > 0) {
        pos_y = btn.top;
      } else {
        pos_y = btn.bottom - height;
      }
      if (snap_x > 0) {
        pos_x = btn.right + pad;
      } else if (snap_x < 0) {
        pos_x = btn.left - width - pad;
      } else if (align_x > 0) {
        pos_x = btn.left;
      } else {
        pos_x = btn.right - width;
      }
      if (pos_x >= btn.right) {
        bar_x = btn.right + pad;
        bar_y = btn.top + (btn.height / 2);
        bar_h = 12;
        bar_w = 6;
      } else if (pos_x + width <= btn.left) {
        bar_x = btn.left - pad;
        bar_y = btn.top + (btn.height / 2);
        bar_h = 12;
        bar_w = 6;
      } else if (pos_y >= btn.bottom) {
        bar_x = btn.left + (btn.width / 2);
        bar_y = btn.bottom + pad;
        bar_h = 6;
        bar_w = 12;
      } else {
        bar_x = btn.left + (btn.width / 2);
        bar_y = btn.top - pad;
        bar_h = 6;
        bar_w = 12;
      }
      pos_y = Math.clamp(pos_y, min_y, max_y) - overlay_rect.top;
      pos_x = Math.clamp(pos_x, min_x, max_x) - overlay_rect.left;
      return {
        // pos_y = Math.max(pos_y,pad)
        // pos_y = Math.min(pos_y,window.innerHeight - pad - height)
        // pos_x = Math.max(pos_x,pad)
        // pos_x = Math.min(pos_x,window.innerWidth - pad - width)
        x: pos_x,
        y: pos_y,
        bar_x: bar_x - overlay_rect.left,
        bar_y: bar_y - overlay_rect.top,
        bar_w: bar_w,
        bar_h: bar_h,
        width: width,
        height: height
      };
    }

    overlayRef(el) {
      boundMethodCheck(this, HoverBox);
      return this._overlay = el;
    }

    UNSAFE_componentWillUpdate() {
      var overlay_rect;
      overlay_rect = this._overlay.getBoundingClientRect();
      this.state.offset_left = overlay_rect.left;
      return this.state.offset_top = overlay_rect.top;
    }

    componentDidUpdate(prev_props, prev_state) {
      // log @props.show_delay
      // if
      // log @props.visible,@state.render_box
      if (this.props.visible && this._hide_box_timer) {
        this.resetHideTimer();
      }
      if (this.props.visible !== prev_props.visible || this.props.visible !== this.state.visible) {
        if (this.props.visible) {
          // log 'RENDER'
          this.resetHideTimer();
          if (this.props.visible_delay) {
            return this._render_box_timer = setTimeout(() => {
              this._render_box_timer = null;
              return this.setState({
                visible: true
              });
            }, this.props.show_delay != null ? this.props.show_delay : 600);
          } else {
            return this.setState({
              visible: true
            });
          }
        } else {
          this.resetHideTimer();
          return this._hide_box_timer = setTimeout(() => {
            this._hide_box_timer = null;
            return this.setState({
              visible: false
            });
          }, this.props.hide_delay != null ? this.props.hide_delay : 200);
        }
      }
    }

    resetHideTimer() {
      boundMethodCheck(this, HoverBox);
      clearTimeout(this._hide_box_timer);
      clearTimeout(this._render_box_timer);
      this._render_box_timer = null;
      return this._hide_box_timer = null;
    }

    onMouseEnter() {
      boundMethodCheck(this, HoverBox);
      this.setState({
        hover: true
      });
      return this.resetHideTimer();
    }

    onMouseLeave() {
      boundMethodCheck(this, HoverBox);
      this.setState({
        hover: false
      });
      this.resetHideTimer();
      return this.forceUpdate();
    }

    onClickOverlay(e) {
      var ref;
      boundMethodCheck(this, HoverBox);
      if (e.target === this._overlay) {
        if ((ref = this._box) != null) {
          if (typeof ref.onClose === "function") {
            ref.onClose(e);
          }
        }
        return this.props.onClickOverlay(e);
      }
    }

    setBackdropColor(bg, alpha) {
      boundMethodCheck(this, HoverBox);
      if (bg === 'none') {
        return 'none';
      }
      return Color(bg).alpha(alpha).string();
    }

    refBox(el) {
      boundMethodCheck(this, HoverBox);
      return this._box = el;
    }

    render() {
      var base, base1, box, box_bar, close_btn, overlay_background, pos;
      if (this.state.visible || this.props.visible) {
        pos = this.getBoxPosition();
      }
      if (this.props.onClickOverlay && this.state.visible) {
        overlay_background = this.setBackdropColor(this.props.background, 0.7);
      } else {
        overlay_background = this.setBackdropColor(this.props.background, 0.0);
      }
      if (this.props.flat && this.state.visible) {
        box = h('div', {
          className: css['hover-box-flat'],
          onMouseEnter: this.props.box_pointer_events && this.onMouseEnter || null,
          onMouseLeave: this.props.box_pointer_events && this.onMouseLeave || null,
          style: {
            pointerEvents: this.props.box_pointer_events && 'all' || 'none',
            top: pos.y,
            left: pos.x,
            width: pos.width,
            height: pos.height,
            color: this.context.primary.color[0]
          }
        }, typeof (base = this.props).renderContent === "function" ? base.renderContent(this.state.offset_left, this.state.offset_top, this.refBox) : void 0);
      } else if (this.state.visible) {
        box = h('div', {
          className: cn(css['hover-box'], css['modal-shadow'], css['hover-box-scroll']),
          onMouseEnter: this.props.box_pointer_events && this.onMouseEnter || null,
          onMouseLeave: this.props.box_pointer_events && this.onMouseLeave || null,
          style: {
            pointerEvents: this.props.box_pointer_events && 'all' || 'none',
            top: pos.y,
            left: pos.x,
            width: pos.width,
            height: pos.height,
            color: this.context.primary.color[0],
            background: this.context.primary.inv[0]
          }
        }, typeof (base1 = this.props).renderContent === "function" ? base1.renderContent(this.state.offset_left, this.state.offset_top, this.refBox) : void 0);
      }
      if (this.props.visible || this.state.visible) {
        box_bar = h('div', {
          className: css['hover-box-bar'],
          style: {
            top: pos.bar_y,
            left: pos.bar_x,
            width: pos.bar_w,
            height: pos.bar_h,
            background: this.context.secondary.inv[0]
          }
        });
      }
      if (pos & this.props.show_close_btn) {
        close_btn = h(Input, {
          type: 'button',
          i: 'close',
          big: true,
          onClick: this.props.onClickOverlay && this.onClickOverlay,
          style: {
            color: 'white',
            position: 'fixed',
            background: 'none',
            left: pos.x + pos.width - DIM - 3.75,
            top: pos.y - DIM - 3.75 - 3.75
          },
          i_style: {
            color: 'white'
          }
        });
      }
      return h('div', {
        ref: this.overlayRef,
        onMouseDown: (e) => {
          return this.setState({
            down_target: e.target
          });
        },
        onMouseUp: (e) => {
          if (e.target !== this.state.down_target) {
            return;
          }
          return this.props.onClickOverlay && this.onClickOverlay(e);
        },
        className: cn(css['hover-box-overlay'], this.state.visible && this.props.onClickOverlay && css['visible']),
        style: {
          background: overlay_background
        }
      }, box, close_btn);
    }

  };

  HoverBox.contextType = StyleContext;

  module.exports = HoverBox;

}).call(this);

//# sourceMappingURL=HoverBox.js.map
